<!DOCTYPE html>

<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="utf-8" />
    <title>My Blog - 2021-11-K3RN3LCTF - WannaSwirl</title>

    <!-- Meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="Abraxus">
    <!-- FontAwesome JS-->
    <script defer src="../../assets/js/fontawesome.min.js"></script>

    <!-- Theme CSS -->
    <link id="theme-style" rel="stylesheet" href="../../assets/css/style.css">
</head>
<body class="theme-bg-light">

    <header class="header text-center">
    <h1 class="blog-name pt-lg-4 mb-0"><a class="no-text-decoration" href="index.html">Abraxus's Blog</a></h1>

    <nav class="navbar navbar-expand-lg navbar-dark">

        <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navigation" aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        <div id="navigation" class="collapse navbar-collapse flex-column">
            <div class="profile-section pt-3 pt-lg-0">
                <img class="profile-image mb-3 rounded-circle mx-auto" src="../../assets/images/profile.png" alt="image">

                <div class="bio mb-3">Student<br>REV @ K3RN3L4RMY</div><!--//bio-->
                <ul class="social-list list-inline py-3 mx-auto">
                    <li class="list-inline-item"><a href="" target="_blank"><i class="fab fa-twitter fa-fw"></i></a></li>
                    <li class="list-inline-item"><a href="https://github.com/Kasimir123" target="_blank"><i class="fab fa-github-alt fa-fw"></i></a></li>
                    <li class="list-inline-item"><a href="https://www.linkedin.com/in/kasimir-schulz" target="_blank"><i class="fab fa-linkedin-in fa-fw"></i></a></li>
                </ul><!--//social-list-->
                <hr>
            </div><!--//profile-section-->

            <ul class="navbar-nav flex-column text-center">
                <li class="nav-item">
                    <a class="nav-link" href="../../index.html"><i class="fas fa-home fa-fw me-2"></i>Blog Home <i class="fas fa-home fa-fw me-2"></i></a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="../../about.html"><i class="fas fa-user fa-fw me-2"></i>About Me <i class="fas fa-user fa-fw me-2"></i></a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="../../blog-posts.html"><i class="fas fa-bookmark fa-fw me-2"></i>Blog Posts <i class="fas fa-bookmark fa-fw me-2"></i></a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="../../writeups.html"><i class="fas fa-flag fa-fw me-2"></i>Writeups <i class="fas fa-flag fa-fw me-2"></i></a>
                </li>
            </ul>

            <div class="my-2 my-md-3 text-center">
                <a class="btn btn-primary" href="https://github.com/Kasimir123" target="_blank">Get in Touch</a>
            </div>
        </div>
    </nav>
</header>

    <div class="main-wrapper">

        <article class="markdown-section my-5 mx-5">
            <h1 id="k3rn3lctf-wannaswirl-write-up">K3RN3LCTF WannaSwirl Write Up</h1>
<h2 id="details">Details:</h2>
<p>Jeopardy style CTF</p>
<p>Category: Reverse Engineering</p>
<h2 id="write-up">Write up:</h2>
<p>Opening the main function in a decompiler we see:</p>
<div class="lang-c editor-colors"><div style="color:Black;background-color:White;"><pre>
__int64 __fastcall main(<span style="color:Blue;">int</span> a1, <span style="color:Blue;">char</span> **a2, <span style="color:Blue;">char</span> **a3)
{

  <span style="color:Blue;">if</span> ( a1 == 2 )
  {
    sub_2540(path, a2[1], a3);
    sub_24A6(&amp;unk_6180, path);
    std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::_M_dispose(path);
  }
  sub_2540(directory, <span style="color:#A31515;">&quot;&quot;</span>, a3);
  <span style="color:Blue;">while</span> ( 1 )
  {
    std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::basic_string(path, &amp;unk_6180);
    v3 = sub_2663(path);
    std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::_M_dispose(path);
    <span style="color:Blue;">if</span> ( v3 &lt;= 0 )
      <span style="color:Blue;">break</span>;
    std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::basic_string(path, directory);
    sub_29E3((<span style="color:Blue;">unsigned</span> <span style="color:Blue;">int</span>)path, (<span style="color:Blue;">unsigned</span> <span style="color:Blue;">int</span>)directory, v4, v5, v6, v7, directory[0]);
    std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::_M_dispose(path);
  }
  std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::basic_string(path, directory);
  sub_29E3((<span style="color:Blue;">unsigned</span> <span style="color:Blue;">int</span>)path, (<span style="color:Blue;">unsigned</span> <span style="color:Blue;">int</span>)directory, v8, v9, v10, v11, directory[0]);
  std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::_M_dispose(path);
  std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::_M_dispose(directory);
  <span style="color:Blue;">return</span> 0LL;
}
</pre></div>
</div>
<div class="lang-c editor-colors"><div style="color:Black;background-color:White;"><pre>
 <span style="color:Blue;">if</span> ( a1 == 2 )
  {
    sub_2540(path, a2[1], a3);
    sub_24A6(&amp;unk_6180, path);
    std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::_M_dispose(path);
  }
</pre></div>
</div>
<p>We see that the function checks if a1 is equal to 2, since this is the main function we know that a1 is argc, so this check passes when we pass an argument to the binary. In the if statement we set the path to the command line argument.</p>
<div class="lang-c editor-colors"><div style="color:Black;background-color:White;"><pre>
  sub_2540(directory, <span style="color:#A31515;">&quot;&quot;</span>, a3);
  <span style="color:Blue;">while</span> ( 1 )
  {
    std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::basic_string(path, &amp;unk_6180);
    v3 = sub_2663(path);
    std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::_M_dispose(path);
    <span style="color:Blue;">if</span> ( v3 &lt;= 0 )
      <span style="color:Blue;">break</span>;
    std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::basic_string(path, directory);
    sub_29E3((<span style="color:Blue;">unsigned</span> <span style="color:Blue;">int</span>)path, (<span style="color:Blue;">unsigned</span> <span style="color:Blue;">int</span>)directory, v4, v5, v6, v7, directory[0]);
    std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::_M_dispose(path);
  }
  std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::basic_string(path, directory);
  sub_29E3((<span style="color:Blue;">unsigned</span> <span style="color:Blue;">int</span>)path, (<span style="color:Blue;">unsigned</span> <span style="color:Blue;">int</span>)directory, v8, v9, v10, v11, directory[0]);
  std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::_M_dispose(path);
  std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::_M_dispose(directory);
</pre></div>
</div>
<p>We then set the directory to &quot;&quot; and then enter a while loop. We pass the path to sub_2663 and check for the response, if the value is less than or equal to 0 we break out of the loop. Otherwise we call the other function.</p>
<p>First we want to analyze sub_2663:</p>
<div class="lang-c editor-colors"><div style="color:Black;background-color:White;"><pre>
__int64 __fastcall sub_2663(<span style="color:Blue;">const</span> <span style="color:Blue;">char</span> **a1)
{
  <span style="color:Blue;">unsigned</span> <span style="color:Blue;">int</span> v1; <span style="color:Green;">// er12</span>
  DIR *v2; <span style="color:Green;">// rbx</span>
  <span style="color:Blue;">struct</span> dirent *i; <span style="color:Green;">// rax</span>

  v1 = 0;
  v2 = opendir(*a1);
  <span style="color:Blue;">for</span> ( i = readdir(v2); i; i = readdir(v2) )
  {
    <span style="color:Blue;">if</span> ( i-&gt;d_type == 4 &amp;&amp; i-&gt;d_name[0] != 46 )
      ++v1;
  }
  <span style="color:Blue;">return</span> v1;
}
</pre></div>
</div>
<p>We know that a1 is the path since we use opendir using that string. We then attempt to all the items in the directory. Looking up d_type on the object returned from readdir we can see that 4 is the enum for DT_DIR. So this function increments v1 for every directory in the directory that doesn't start with &quot;.&quot;. This means this function is most likely used to count the number of directories within the current directory.</p>
<p>Going back into the main loop we go to look at the other function that is called:</p>
<div class="lang-c editor-colors"><div style="color:Black;background-color:White;"><pre>
__int64 __fastcall sub_29E3(__int64 a1)
{

  std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::basic_string(name, &amp;qword_6180);
  std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::append(name, a1);
  v1 = opendir(name[0]);
  std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::basic_string(v8, &amp;qword_6180);
  std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::basic_string(v10, name);
  <span style="color:Blue;">if</span> ( v10[1] == (<span style="color:Blue;">const</span> <span style="color:Blue;">char</span> *)0x3FFFFFFFFFFFFFFFLL )
    std::__throw_length_error(<span style="color:#A31515;">&quot;basic_string::append&quot;</span>);
  std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::_M_append(v10, <span style="color:#A31515;">&quot;/&quot;</span>, 1LL);
  sub_24A6(&amp;qword_6180, v10, v2, v3);
  std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::_M_dispose(v10);
  <span style="color:Blue;">if</span> ( v1 )
  {
    v5 = readdir(v1);
    std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::basic_string(v10, name);
    v6 = sub_2663(v10);
    std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::_M_dispose(v10);
    <span style="color:Blue;">if</span> ( v6 )
    {
      <span style="color:Blue;">while</span> ( v5 )
      {
        std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::basic_string(v10, name);
        sub_2BE4(v10, v5);
        std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::_M_dispose(v10);
        v5 = readdir(v1);
      }
    }
    <span style="color:Blue;">else</span>
    {
      std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::basic_string(v10, a1);
      std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::basic_string(v9, v8);
      sub_2C32(v9, v10, v5, v1);
      std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::_M_dispose(v9);
      std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::_M_dispose(v10);
    }
    std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::resize(
      &amp;qword_6180,
      qword_6188 - 1 - *(_QWORD *)(a1 + 8));
    closedir(v1);
  }
  std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::_M_dispose(v8);
  <span style="color:Blue;">return</span> std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::_M_dispose(name);
}
</pre></div>
</div>
<div class="lang-c editor-colors"><div style="color:Black;background-color:White;"><pre>
  v1 = opendir(name[0]);
  std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::basic_string(v8, &amp;qword_6180);
  std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::basic_string(v10, name);
  <span style="color:Blue;">if</span> ( v10[1] == (<span style="color:Blue;">const</span> <span style="color:Blue;">char</span> *)0x3FFFFFFFFFFFFFFFLL )
    std::__throw_length_error(<span style="color:#A31515;">&quot;basic_string::append&quot;</span>);
  std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::_M_append(v10, <span style="color:#A31515;">&quot;/&quot;</span>, 1LL);
  sub_24A6(&amp;qword_6180, v10, v2, v3);
  std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::_M_dispose(v10);
  <span style="color:Blue;">if</span> ( v1 )
</pre></div>
</div>
<p>The first that happens in this function is that we open the directory and then check if it is null, if it is not null then we continue to the meat of this function:</p>
<div class="lang-c editor-colors"><div style="color:Black;background-color:White;"><pre>
    v5 = readdir(v1);
    std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::basic_string(v10, name);
    v6 = sub_2663(v10);
    std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::_M_dispose(v10);
    <span style="color:Blue;">if</span> ( v6 )
    {
      <span style="color:Blue;">while</span> ( v5 )
      {
        std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::basic_string(v10, name);
        sub_2BE4(v10, v5);
        std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::_M_dispose(v10);
        v5 = readdir(v1);
      }
    }
    <span style="color:Blue;">else</span>
    {
      std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::basic_string(v10, a1);
      std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::basic_string(v9, v8);
      sub_2C32(v9, v10, v5, v1);
      std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::_M_dispose(v9);
      std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::_M_dispose(v10);
    }
    std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::resize(
      &amp;qword_6180,
      qword_6188 - 1 - *(_QWORD *)(a1 + 8));
    closedir(v1);
</pre></div>
</div>
<p>We call readdir on the directory we opened earlier and then call sub_2663 (number of directories) again on the path we used to open the directory.</p>
<p>If the number of directories is not 0 we have:</p>
<div class="lang-c editor-colors"><div style="color:Black;background-color:White;"><pre>
    <span style="color:Blue;">if</span> ( v6 )
    {
      <span style="color:Blue;">while</span> ( v5 )
      {
        std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::basic_string(v10, name);
        sub_2BE4(v10, v5);
        std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::_M_dispose(v10);
        v5 = readdir(v1);
      }
    }
</pre></div>
</div>
<p>We loop while the value from readdir is not null and then we call sub_2BE4 on the directory path and the current entity from readdir:</p>
<div class="lang-c editor-colors"><div style="color:Black;background-color:White;"><pre>
__int64 __fastcall sub_2BE4(__int64 a1, __int64 a2)
{

  <span style="color:Blue;">if</span> ( *(_BYTE *)(a2 + 18) == 4 &amp;&amp; *(_BYTE *)(a2 + 19) != 46 )
  {
    sub_2540(v3, (<span style="color:Blue;">const</span> <span style="color:Blue;">char</span> *)(a2 + 19));
    sub_29E3((__int64)v3);
    result = std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::_M_dispose(v3);
  }
  <span style="color:Blue;">return</span> result;
}
</pre></div>
</div>
<p>In this function we check again if the entity is a directory and doesn't start with &quot;.&quot;, if it is a directory we call the function we were just in.</p>
<p>Going back out to the function we are in we are now going to take a look at the else, what gets run when the number of directories in the current directory is 0:</p>
<div class="lang-c editor-colors"><div style="color:Black;background-color:White;"><pre>
    <span style="color:Blue;">else</span>
    {
      std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::basic_string(v10, a1);
      std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::basic_string(v9, v8);
      sub_2C32(v9, v10, v5, v1);
      std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::_M_dispose(v9);
      std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::_M_dispose(v10);
    }
</pre></div>
</div>
<p>We call some function and pass in the directory path, the entity, and the current diectory as well as one other value which we can reverse to find is the old path before the current directory was added to the path, making it the path one directory up:</p>
<div class="lang-c editor-colors"><div style="color:Black;background-color:White;"><pre>
__int64 __fastcall sub_2C32(__int64 a1, __int64 a2, <span style="color:Blue;">struct</span> dirent *a3, DIR *a4)
{
  _BYTE *v5; <span style="color:Green;">// rax</span>
  <span style="color:Blue;">void</span> *v6; <span style="color:Green;">// r12</span>
  __int64 v7; <span style="color:Green;">// rax</span>
  <span style="color:Blue;">unsigned</span> __int64 v8; <span style="color:Green;">// rdx</span>
  <span style="color:Blue;">char</span> *v9; <span style="color:Green;">// rax</span>
  <span style="color:Blue;">unsigned</span> __int64 v10; <span style="color:Green;">// rdx</span>
  __int64 v11; <span style="color:Green;">// rax</span>
  __int64 v12; <span style="color:Green;">// rbx</span>
  <span style="color:Blue;">char</span> *v13; <span style="color:Green;">// r14</span>
  __int64 v14; <span style="color:Green;">// rax</span>
  __int64 v15; <span style="color:Green;">// rax</span>
  size_t size; <span style="color:Green;">// [rsp+8h] [rbp-2E0h]</span>
  __int64 v18; <span style="color:Green;">// [rsp+10h] [rbp-2D8h]</span>
  <span style="color:Blue;">char</span> v20[32]; <span style="color:Green;">// [rsp+28h] [rbp-2C0h] BYREF</span>
  __int64 v21[4]; <span style="color:Green;">// [rsp+48h] [rbp-2A0h] BYREF</span>
  _QWORD v22[4]; <span style="color:Green;">// [rsp+68h] [rbp-280h] BYREF</span>
  <span style="color:Blue;">char</span> *command[2]; <span style="color:Green;">// [rsp+88h] [rbp-260h] BYREF</span>
  <span style="color:Blue;">unsigned</span> __int64 v24; <span style="color:Green;">// [rsp+98h] [rbp-250h] BYREF</span>
  __int64 v25[2]; <span style="color:Green;">// [rsp+A8h] [rbp-240h] BYREF</span>
  <span style="color:Blue;">unsigned</span> __int64 v26; <span style="color:Green;">// [rsp+B8h] [rbp-230h] BYREF</span>

  std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::basic_string(v20, a1);
  std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::append(v20, a2);
  v5 = malloc(0x3E8uLL);
  size = 1000LL;
  *v5 = 0;
  v6 = v5;
  v18 = 0LL;
  <span style="color:Blue;">while</span> ( a3 )
  {
    <span style="color:Blue;">if</span> ( a3-&gt;d_type == 8 )
    {
      sub_2540(v25, a3-&gt;d_name);
      sub_2540(v22, <span style="color:#A31515;">&quot;/&quot;</span>);
      v7 = std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::insert(v22, 0LL, v20);
      std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::basic_string(command, v7);
      v8 = 15LL;
      v9 = &amp;command[1][v25[1]];
      <span style="color:Blue;">if</span> ( (<span style="color:Blue;">unsigned</span> __int64 *)command[0] != &amp;v24 )
        v8 = v24;
      <span style="color:Blue;">if</span> ( (<span style="color:Blue;">unsigned</span> __int64)v9 &lt;= v8 )
        <span style="color:Blue;">goto</span> LABEL_13;
      v10 = 15LL;
      <span style="color:Blue;">if</span> ( (<span style="color:Blue;">unsigned</span> __int64 *)v25[0] != &amp;v26 )
        v10 = v26;
      <span style="color:Blue;">if</span> ( (<span style="color:Blue;">unsigned</span> __int64)v9 &gt; v10 )
LABEL_13:
        v11 = std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::append(command, v25);
      <span style="color:Blue;">else</span>
        v11 = std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::insert(v25, 0LL, command);
      std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::basic_string(v21, v11);
      std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::_M_dispose(command);
      std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::_M_dispose(v22);
      std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::_M_dispose(v25);
      std::ifstream::basic_ifstream(v25, v21[0], 6LL);
      v12 = std::istream::tellg((std::istream *)v25);
      v13 = (<span style="color:Blue;">char</span> *)<span style="color:Blue;">operator</span> <span style="color:Blue;">new</span>[](v12 + 1);
      std::istream::seekg(v25, 0LL, 0LL);
      std::istream::read((std::istream *)v25, v13, v12);
      std::ifstream::close(v25);
      v13[v12] = 0;
      <span style="color:Blue;">while</span> ( v18 + strlen(v13) &gt; size )
      {
        size *= 2LL;
        v6 = realloc(v6, size);
      }
      strcat((<span style="color:Blue;">char</span> *)v6, v13);
      v18 += v12;
      free(v13);
      std::ifstream::~ifstream(v25);
      std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::_M_dispose(v21);
    }
    a3 = readdir(a4);
  }
  sub_2540(v25, <span style="color:#A31515;">&quot;.txt&quot;</span>);
  v14 = std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::insert(v25, 0LL, v20);
  std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::basic_string(v22, v14);
  std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::_M_dispose(v25);
  sub_2540(v25, <span style="color:#A31515;">&quot;rm -rf &quot;</span>);
  v15 = std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::append(v25, v20);
  std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::basic_string(command, v15);
  std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::_M_dispose(v25);
  system(command[0]);
  std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::basic_string(v25, v22);
  sub_26A3(v18, v6, v25);
  std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::_M_dispose(v25);
  free(v6);
  std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::_M_dispose(command);
  std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::_M_dispose(v22);
  <span style="color:Blue;">return</span> std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::_M_dispose(v20);
}
</pre></div>
</div>
<p>This is a pretty meaty function so I decided to split it apart quite a bit, the first thing I did was look at what was at the big while loop:</p>
<div class="lang-c editor-colors"><div style="color:Black;background-color:White;"><pre>
  <span style="color:Blue;">while</span> ( a3 )
  {
    <span style="color:Blue;">if</span> ( a3-&gt;d_type == 8 )
    {
      sub_2540(v25, a3-&gt;d_name);
      sub_2540(v22, <span style="color:#A31515;">&quot;/&quot;</span>);
      v7 = std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::insert(v22, 0LL, v20);
      std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::basic_string(command, v7);
      v8 = 15LL;
      v9 = &amp;command[1][v25[1]];
      <span style="color:Blue;">if</span> ( (<span style="color:Blue;">unsigned</span> __int64 *)command[0] != &amp;v24 )
        v8 = v24;
      <span style="color:Blue;">if</span> ( (<span style="color:Blue;">unsigned</span> __int64)v9 &lt;= v8 )
        <span style="color:Blue;">goto</span> LABEL_13;
      v10 = 15LL;
      <span style="color:Blue;">if</span> ( (<span style="color:Blue;">unsigned</span> __int64 *)v25[0] != &amp;v26 )
        v10 = v26;
      <span style="color:Blue;">if</span> ( (<span style="color:Blue;">unsigned</span> __int64)v9 &gt; v10 )
LABEL_13:
        v11 = std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::append(command, v25);
      <span style="color:Blue;">else</span>
        v11 = std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::insert(v25, 0LL, command);
      std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::basic_string(v21, v11);
      std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::_M_dispose(command);
      std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::_M_dispose(v22);
      std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::_M_dispose(v25);
      std::ifstream::basic_ifstream(v25, v21[0], 6LL);
      v12 = std::istream::tellg((std::istream *)v25);
      v13 = (<span style="color:Blue;">char</span> *)<span style="color:Blue;">operator</span> <span style="color:Blue;">new</span>[](v12 + 1);
      std::istream::seekg(v25, 0LL, 0LL);
      std::istream::read((std::istream *)v25, v13, v12);
      std::ifstream::close(v25);
      v13[v12] = 0;
      <span style="color:Blue;">while</span> ( v18 + strlen(v13) &gt; size )
      {
        size *= 2LL;
        v6 = realloc(v6, size);
      }
      strcat((<span style="color:Blue;">char</span> *)v6, v13);
      v18 += v12;
      free(v13);
      std::ifstream::~ifstream(v25);
      std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::_M_dispose(v21);
    }
    a3 = readdir(a4);
  }
</pre></div>
</div>
<p>Again here we seem to be looping through all of the items in the directory. However, this time we compare to a different enum (we can look this up to see it is DT_REG, or just regular files). We then seem to be doing some string work in order get the path to the current file, we know this since we use the current directory string, &quot;/&quot;, and the current entity name. We then get the length of the file using seekg and we read the file into memory. We then reallocate the char array is we are above a certain size and hen we concatenate what we just read to another array.</p>
<p>After having concatenated all of the file contents into the array we move on the section after the while loop.</p>
<div class="lang-c editor-colors"><div style="color:Black;background-color:White;"><pre>
  sub_2540(v25, <span style="color:#A31515;">&quot;.txt&quot;</span>);
  v14 = std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::insert(v25, 0LL, v20);
  std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::basic_string(v22, v14);
  std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::_M_dispose(v25);
  sub_2540(v25, <span style="color:#A31515;">&quot;rm -rf &quot;</span>);
  v15 = std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::append(v25, v20);
  std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::basic_string(command, v15);
  std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::_M_dispose(v25);
  system(command[0]);
  std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::basic_string(v25, v22);
  sub_26A3(v18, v6, v25);
  std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::_M_dispose(v25);
  free(v6);
  std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::_M_dispose(command);
  std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::_M_dispose(v22);
  <span style="color:Blue;">return</span> std::__cxx11::basic_string&lt;<span style="color:Blue;">char</span>,std::char_traits&lt;<span style="color:Blue;">char</span>&gt;,std::allocator&lt;<span style="color:Blue;">char</span>&gt;&gt;::_M_dispose(v20);
</pre></div>
</div>
<p>First we append &quot;.txt&quot; and the directory path to some new string. We then call rm -rf on the directory and then pass the concatenated bytes to another function, sub_26A3:</p>
<div class="lang-c editor-colors"><div style="color:Black;background-color:White;"><pre>
__int64 __fastcall sub_26A3(__int64 a1, <span style="color:Blue;">void</span> *a2, _QWORD *a3)
{

  v3 = a1;
  std::ofstream::basic_ofstream(v51, *a3, 4LL);
  v4 = sub_25CA(a1);
  v47 = realloc(a2, a1 + v4);
LABEL_2:
  v5 = sqrt((<span style="color:Blue;">double</span>)(<span style="color:Blue;">int</span>)v3);
  v6 = 0LL;
  v7 = (<span style="color:Blue;">unsigned</span> <span style="color:Blue;">int</span>)(<span style="color:Blue;">int</span>)v5;
  <span style="color:Blue;">while</span> ( 1 )
  {
    <span style="color:Blue;">if</span> ( v7 + 1 &lt; v6 )
    {
      v47[v3++] = 0;
      <span style="color:Blue;">goto</span> LABEL_2;
    }
    v8 = v6 + v7;
    v9 = v3 / (v6 + v7);
    v46 = v9;
    v10 = v3 % (v6 + v7);
    <span style="color:Blue;">if</span> ( !v10 )
      <span style="color:Blue;">break</span>;
    ++v6;
  }
  v11 = 8 * v9;
  v12 = 0LL;
  v13 = malloc(8 * v9);
  v14 = (_DWORD **)malloc(v11);
  v15 = 8 * v8;
  v16 = v14;
  <span style="color:Blue;">while</span> ( v12 &lt; v46 )
  {
    v49 = v15;
    v13[v12] = malloc(v15);
    v17 = malloc(4 * v8);
    v15 = v49;
    v16[v12++] = v17;
  }
  v18 = 0LL;
  v19 = 0;
  v20 = 0LL;
  <span style="color:Blue;">while</span> ( v18 &lt; v46 )
  {
    <span style="color:Blue;">for</span> ( i = 0LL; i &lt; v8; ++i )
    {
      *(_BYTE *)(v13[v18] + i) = v47[v20 + i];
      v16[v18][i] = v19 + i;
    }
    ++v18;
    v20 += v8;
    v19 += v8;
  }
  v22 = v3;
  v23 = 1;
  size = 4LL * (<span style="color:Blue;">int</span>)v3;
  v24 = malloc(size);
  v25 = 69;
  v26 = v24;
  *v24 = **v16;
  <span style="color:Blue;">while</span> ( v23 &lt; v22 )
  {
    v27 = v25;
    v50 = v25;
    sub_2606(v25, 1);
    v28 = sub_2606(v27, 0);
    v32 = v31 + v28;
    <span style="color:Blue;">switch</span> ( v25 )
    {
      <span style="color:Blue;">case</span> &#39;N&#39;:
        v33 = v30 &gt;&gt; 2 &lt;= v32;
        <span style="color:Blue;">goto</span> LABEL_27;
      <span style="color:Blue;">case</span> &#39;E&#39;:
        v34 = v29;
        v35 = v8;
        v36 = v30 &gt;&gt; 2;
        <span style="color:Blue;">goto</span> LABEL_23;
      <span style="color:Blue;">case</span> &#39;S&#39;:
        v35 = v46;
        v34 = v32;
        v36 = v30 &gt;&gt; 2;
LABEL_23:
        <span style="color:Blue;">if</span> ( v34 &gt;= v35 - v36 )
          <span style="color:Blue;">goto</span> LABEL_28;
LABEL_30:
        v37 = v23++;
        v26[v37] = v16[v32][v29];
        <span style="color:Blue;">break</span>;
      <span style="color:Blue;">case</span> &#39;W&#39;:
        v33 = v30 &gt;&gt; 2 &lt;= v29;
LABEL_27:
        <span style="color:Blue;">if</span> ( v33 )
          <span style="color:Blue;">goto</span> LABEL_30;
LABEL_28:
        v25 = sub_263A(v50);
        <span style="color:Blue;">break</span>;
      <span style="color:Blue;">default</span>:
        <span style="color:Blue;">goto</span> LABEL_30;
    }
  }
  v38 = malloc(size);
  v39 = v22 - (__int64)(v22 / 5);
  <span style="color:Blue;">for</span> ( j = v39; v22 &gt; j; ++j )
  {
    v43 = v26[j];
    v38[v10++] = v43;
  }
  v41 = (<span style="color:Blue;">char</span> *)&amp;v38[v10];
  <span style="color:Blue;">if</span> ( v39 &lt; 0 )
    v39 = 0LL;
  v42 = 0;
  qmemcpy(v41, v26, 4 * v39);
  <span style="color:Blue;">while</span> ( v42 &lt; v22 )
  {
    v44 = sub_2656((__int64)v26, v42);
    sub_2522((__int64)v51, v47[v38[v44]]);
    ++v42;
  }
  sub_2522((__int64)v51, 97);
  sub_2522((__int64)v51, 98);
  sub_2522((__int64)v51, 114);
  sub_2522((__int64)v51, 111);
  sub_2522((__int64)v51, 108);
  sub_2522((__int64)v51, 121);
  std::ofstream::close(v51);
  <span style="color:Blue;">return</span> std::ofstream::~ofstream(v51);
}
</pre></div>
</div>
<p>This function was pretty obviously the algorithm so lets get started:</p>
<div class="lang-c editor-colors"><div style="color:Black;background-color:White;"><pre>
  v3 = a1;
  std::ofstream::basic_ofstream(v51, *a3, 4LL);
  v4 = sub_25CA(a1);
  v47 = realloc(a2, a1 + v4);
</pre></div>
</div>
<p>We start off by opening an outstream and then we call sub_25CA:</p>
<div class="lang-c editor-colors"><div style="color:Black;background-color:White;"><pre>
__int64 __fastcall sub_25CA(__int64 a1)
{

  v1 = a1;
  <span style="color:Blue;">do</span>
  {
    v2 = (<span style="color:Blue;">double</span>)(<span style="color:Blue;">int</span>)v1;
    v3 = v1;
    v4 = v1++;
    v5 = v3 - a1;
    v6 = sqrt(v2);
  }
  <span style="color:Blue;">while</span> ( v4 != (<span style="color:Blue;">unsigned</span> <span style="color:Blue;">int</span>)(<span style="color:Blue;">int</span>)v6 * (<span style="color:Blue;">unsigned</span> __int64)(<span style="color:Blue;">unsigned</span> <span style="color:Blue;">int</span>)(<span style="color:Blue;">int</span>)v6 );
  <span style="color:Blue;">return</span> v5;
}
</pre></div>
</div>
<p>This function seems to start with the length that is passed to it and then increases that value till it is a perfect square, we then return the difference between the perfect square and the current length.</p>
<p>After the function call we allocate the perfect square length of data. The next component of the algorithm is a while loop:</p>
<div class="lang-c editor-colors"><div style="color:Black;background-color:White;"><pre>
LABEL_2:
  v5 = sqrt((<span style="color:Blue;">double</span>)(<span style="color:Blue;">int</span>)v3);
  v6 = 0LL;
  v7 = (<span style="color:Blue;">unsigned</span> <span style="color:Blue;">int</span>)(<span style="color:Blue;">int</span>)v5;
  <span style="color:Blue;">while</span> ( 1 )
  {
    <span style="color:Blue;">if</span> ( v7 + 1 &lt; v6 )
    {
      v47[v3++] = 0;
      <span style="color:Blue;">goto</span> LABEL_2;
    }
    v8 = v6 + v7;
    v9 = v3 / (v6 + v7);
    v46 = v9;
    v10 = v3 % (v6 + v7);
    <span style="color:Blue;">if</span> ( !v10 )
      <span style="color:Blue;">break</span>;
    ++v6;
  }
</pre></div>
</div>
<p>This loop keeps looping until v3 (length) modded by v6 plus v7 was equal to 0. v7 starts out by being the sqrt of the length of the data. We then keep incrementing v6 from 0 till we reach the checkpoint. If we are unable to make the data rectangle shaped (perfectly dividing closest square plus a value less than or equal to that value) then we add a \x00 to the end of the data and redo the loop.</p>
<p>We then move on to the next loop:</p>
<div class="lang-c editor-colors"><div style="color:Black;background-color:White;"><pre>
  v11 = 8 * v9;
  v12 = 0LL;
  v13 = malloc(8 * v9);
  v14 = (_DWORD **)malloc(v11);
  v15 = 8 * v8;
  v16 = v14;
  <span style="color:Blue;">while</span> ( v12 &lt; v46 )
  {
    v49 = v15;
    v13[v12] = malloc(v15);
    v17 = malloc(4 * v8);
    v15 = v49;
    v16[v12++] = v17;
  }
</pre></div>
</div>
<p>What we are doing here is just going through and mallocing space for all the data we need to shuffle around. We then move on to the next loop:</p>
<div class="lang-c editor-colors"><div style="color:Black;background-color:White;"><pre>
  v18 = 0LL;
  v19 = 0;
  v20 = 0LL;
  <span style="color:Blue;">while</span> ( v18 &lt; v46 )
  {
    <span style="color:Blue;">for</span> ( i = 0LL; i &lt; v8; ++i )
    {
      *(_BYTE *)(v13[v18] + i) = v47[v20 + i];
      v16[v18][i] = v19 + i;
    }
    ++v18;
    v20 += v8;
    v19 += v8;
  }
</pre></div>
</div>
<p>In this function we are creating two different arrays, one with the values from the original data, and the other is the index we used to get that value from the original data. Ok, time for the next section:</p>
<div class="lang-c editor-colors"><div style="color:Black;background-color:White;"><pre>
 v22 = v3;
  v23 = 1;
  size = 4LL * (<span style="color:Blue;">int</span>)v3;
  v24 = malloc(size);
  v25 = 69;
  v26 = v24;
  *v24 = **v16;
  <span style="color:Blue;">while</span> ( v23 &lt; v22 )
  {
    v27 = v25;
    v50 = v25;
    sub_2606(v25, 1);
    v28 = sub_2606(v27, 0);
    v32 = v31 + v28;
    <span style="color:Blue;">switch</span> ( v25 )
    {
      <span style="color:Blue;">case</span> &#39;N&#39;:
        v33 = v30 &gt;&gt; 2 &lt;= v32;
        <span style="color:Blue;">goto</span> LABEL_27;
      <span style="color:Blue;">case</span> &#39;E&#39;:
        v34 = v29;
        v35 = v8;
        v36 = v30 &gt;&gt; 2;
        <span style="color:Blue;">goto</span> LABEL_23;
      <span style="color:Blue;">case</span> &#39;S&#39;:
        v35 = v46;
        v34 = v32;
        v36 = v30 &gt;&gt; 2;
LABEL_23:
        <span style="color:Blue;">if</span> ( v34 &gt;= v35 - v36 )
          <span style="color:Blue;">goto</span> LABEL_28;
LABEL_30:
        v37 = v23++;
        v26[v37] = v16[v32][v29];
        <span style="color:Blue;">break</span>;
      <span style="color:Blue;">case</span> &#39;W&#39;:
        v33 = v30 &gt;&gt; 2 &lt;= v29;
LABEL_27:
        <span style="color:Blue;">if</span> ( v33 )
          <span style="color:Blue;">goto</span> LABEL_30;
LABEL_28:
        v25 = sub_263A(v50);
        <span style="color:Blue;">break</span>;
      <span style="color:Blue;">default</span>:
        <span style="color:Blue;">goto</span> LABEL_30;
    }
  }
</pre></div>
</div>
<p>The first thing we need to figure out in this function is what the sub_2606 function does:</p>
<div class="lang-c editor-colors"><div style="color:Black;background-color:White;"><pre>
__int64 __fastcall sub_2606(<span style="color:Blue;">char</span> a1, <span style="color:Blue;">int</span> a2)
{
  <span style="color:Blue;">bool</span> v2; <span style="color:Green;">// al</span>
  __int64 result; <span style="color:Green;">// rax</span>

  <span style="color:Blue;">if</span> ( a1 != 78 )
  {
    <span style="color:Blue;">if</span> ( a1 == 69 )
    {
      LOBYTE(result) = a2 == 1;
    }
    <span style="color:Blue;">else</span>
    {
      <span style="color:Blue;">if</span> ( a1 != 83 )
      {
        v2 = a2 == 1;
        <span style="color:Blue;">return</span> (<span style="color:Blue;">unsigned</span> <span style="color:Blue;">int</span>)-v2;
      }
      LOBYTE(result) = a2 != 1;
    }
    <span style="color:Blue;">return</span> (<span style="color:Blue;">unsigned</span> __int8)result;
  }
  v2 = a2 != 1;
  <span style="color:Blue;">return</span> (<span style="color:Blue;">unsigned</span> <span style="color:Blue;">int</span>)-v2;
}
</pre></div>
</div>
<p>This function gets passed 2 values, a1 is either 'N', 'E', 'S', or 'W', while a2 is either 1 or 0. This function then either returns 1, 0, or -1 based on a1 and a2.</p>
<p>We also have another function, sub_263A, that we need to consider:</p>
<div class="lang-c editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">char</span> __fastcall sub_263A(<span style="color:Blue;">char</span> a1)
{
  <span style="color:Blue;">char</span> result; <span style="color:Green;">// al</span>

  result = 69;
  <span style="color:Blue;">if</span> ( a1 != 78 )
  {
    result = 83;
    <span style="color:Blue;">if</span> ( a1 != 69 )
      result = 9 * (a1 == 83) + 78;
  }
  <span style="color:Blue;">return</span> result;
}
</pre></div>
</div>
<p>This function takes in either 'N', 'E', 'S', or 'W' and then returns another value based on that.</p>
<p>Looking back at the algorithm, we can see that we loop through the length of the data and then get two different directions, then based on an if statement  we either get a new move direction or we copy data from the second array to the new array we malloced.</p>
<p>We then move on to the next section:</p>
<div class="lang-c editor-colors"><div style="color:Black;background-color:White;"><pre>
  v38 = malloc(size);
  v39 = v22 - (__int64)(v22 / 5);
  <span style="color:Blue;">for</span> ( j = v39; v22 &gt; j; ++j )
  {
    v43 = v26[j];
    v38[v10++] = v43;
  }
  v41 = (<span style="color:Blue;">char</span> *)&amp;v38[v10];
  <span style="color:Blue;">if</span> ( v39 &lt; 0 )
    v39 = 0LL;
  v42 = 0;
  qmemcpy(v41, v26, 4 * v39);
  <span style="color:Blue;">while</span> ( v42 &lt; v22 )
  {
    v44 = sub_2656((__int64)v26, v42);
    sub_2522((__int64)v51, v47[v38[v44]]);
    ++v42;
  }
  sub_2522((__int64)v51, 97);
  sub_2522((__int64)v51, 98);
  sub_2522((__int64)v51, 114);
  sub_2522((__int64)v51, 111);
  sub_2522((__int64)v51, 108);
  sub_2522((__int64)v51, 121);
  std::ofstream::close(v51);
</pre></div>
</div>
<p>We then malloc a new byte array and move data from the array we just made into the array. We move the data by first getting a value by dividing the length by 5 and then we move the data starting at that index to the end of the data to the new array. Then we move the data from the start to that index over. So something like abcde would become bcdea.</p>
<p>After that we loop through all the data and write it out to a file, after writing all the data we write abroly to the file as well, and then close the file.</p>
<p>From here you can make a python version of the algorithm:</p>
<div class="lang-py editor-colors"># Imports
import numpy as np

# Factor the length as square-like as possible
# for maximum swirlage
def factosize(msg):
    ln = len(msg)
    # Start at the square
    start = int(np.sqrt(ln))
    # Keep checking
    for i in range((start+2)//1):
        x = start + i
        if ln % x == 0:
            return ln // x, x
    return "Not square enough! :C"

def WannaSwirl(in_bytes, nperm=-1):

    # Ceil function
    def ceil(a, b):
        return -(-a // b)

    # Shape input bytes to a matrix
    while True:
        arrshape = factosize(in_bytes)
        if type(arrshape) != str:
            break
        # Add padding when necessary
        in_bytes += b'\x00'
    bytmat = np.array(list(in_bytes)).reshape(arrshape)
    
    # Some standard amount of swirl
    if nperm < 0:
        nperm = bytmat.size//5
    
    # Move dictionaries
    move_dic = {'N':(-1,0),'E':(0,1),'S':(1,0),'W':(0,-1)}
    turn_dic = {'N':'E','E':'S','S':'W','W':'N'}
    
    # SWIRL TIME 
    i_mat = np.arange(bytmat.size).reshape(bytmat.shape)
    # Get matrix shape
    h, w = bytmat.shape
    # Initial conditions
    y,x = 0,0    # start at 0,0
    movdir = 'E' # start going East
    vortex = [i_mat[y,x]]
    # Loop time
    i = 1
    while len(vortex) < i_mat.size:
        try:
            # Get new coords
            xnew = x + move_dic[movdir][1]
            ynew = y + move_dic[movdir][0]
            # Check if we hit an edge or a previous path
            if (movdir=='N') and (ynew < i//4): raise
            if (movdir=='E') and (xnew >= w-i//4): raise
            if (movdir=='S') and (ynew >= h-i//4): raise
            if (movdir=='W') and (xnew < i//4): raise
            # Append it to vortex list
            vortex.append(i_mat[ynew,xnew])
        except:
            # Turn clockwise
            movdir = turn_dic[movdir]
            i += 1
            continue
        # Set new coords
        x = xnew
        y = ynew
    # Permutate vortex
    if (nperm != 0) or (nperm != len(vortex)):
        perm = np.append(vortex[-nperm:], vortex[:-nperm])
    else:
        perm = vortex
    # Permutation dictionary
    perm_dic = { vortex[i] : int(perm[i]) for i in range(bytmat.size) }
    # Swirl the data
    swirled = np.zeros(bytmat.size, dtype=int)
    for i in range(bytmat.size):
        swirled[i] = bytmat.flatten()[ perm_dic[i] ]
    # Ta-da!
    return bytes(list(swirled))

trial = b'flag{}'

enc = (WannaSwirl(trial,nperm=-1)) + b'abroly'
</div>
<p>This works as a proof of concept and if you only encrypt one directory deep using the binary you can get the same result.</p>
<p>I then made a python script to undo what the original swirl function had done. We know that everything is already sized correctly if we remove the abroly at the end so we can just reshape the matrix rather than trying to find the correct size. The vortex will be the same as well, so then all we need to do is use the values from the dictionary to undo what the swirl has done:</p>
<div class="lang-py editor-colors">for i in range(bytmat.size):
   swirled[perm_dic[i]] = msg[i]
</div>
<p>Writing a full script I got:</p>
<div class="lang-py editor-colors"># Imports
import numpy as np
import sys

# Factor the length as square-like as possible
# for maximum swirlage
def factosize(msg):
    ln = len(msg)
    # Start at the square
    start = int(np.sqrt(ln))
    # Keep checking
    for i in range((start+2)//1):
        x = start + i
        if ln % x == 0:
            return ln // x, x
    return "Not square enough! :C"

    
def unswirl(msg):
    bytmat = np.array(list(msg)).reshape(factosize(msg))
    
    # Some standard amount of swirl
    nperm = bytmat.size//5
    
    # Move dictionaries
    move_dic = {'N':(-1,0),'E':(0,1),'S':(1,0),'W':(0,-1)}
    turn_dic = {'N':'E','E':'S','S':'W','W':'N'}
    
    # SWIRL TIME 
    i_mat = np.arange(bytmat.size).reshape(bytmat.shape)
    # Get matrix shape
    h, w = bytmat.shape
    # Initial conditions
    y,x = 0,0    # start at 0,0
    movdir = 'E' # start going East
    vortex = [i_mat[y,x]]
    # Loop time
    i = 1
    while len(vortex) < i_mat.size:
        try:
            # Get new coords
            xnew = x + move_dic[movdir][1]
            ynew = y + move_dic[movdir][0]
            # Check if we hit an edge or a previous path
            if (movdir=='N') and (ynew < i//4): raise
            if (movdir=='E') and (xnew >= w-i//4): raise
            if (movdir=='S') and (ynew >= h-i//4): raise
            if (movdir=='W') and (xnew < i//4): raise
            # Append it to vortex list
            vortex.append(i_mat[ynew,xnew])
        except:
            # Turn clockwise
            movdir = turn_dic[movdir]
            i += 1
            continue
        # Set new coords
        x = xnew
        y = ynew
    # Permutate vortex
    if (nperm != 0) or (nperm != len(vortex)):
        perm = np.append(vortex[-nperm:], vortex[:-nperm])
    else:
        perm = vortex
    # Permutation dictionary
    perm_dic = { vortex[i] : int(perm[i]) for i in range(bytmat.size) }
    # Swirl the data
    swirled = np.zeros(bytmat.size, dtype=int)

    for i in range(bytmat.size):
        swirled[perm_dic[i]] = msg[i]

    return bytes(list(swirled))

enc = open(sys.argv[1], "rb").read().rstrip(b'abroly')

dec = unswirl(enc)
</div>
<p>I then added some code at the bottom of the file to search for the flag:</p>
<div class="lang-py editor-colors">flg = str(dec).index('flag{')

print(str(dec)[flg:flg+100])
</div>
<p>Running this on the original FlagFolder.txt I get:</p>
<pre><code>flag{w0w_1m_g3tt1ng_s0_d1zzy_1_th1nk_1m_g0nn4_puk3}Lorem ipsum dolor sit amet, consectetur adipiscin
</code></pre>
<p>However the original file had an unintended solve where you could simply ctrl + f for { and see the flag so another file was released. Running our solve script on that file we get that the substring wasn't find so I decided to print out dec:</p>
<pre><code>b'QRSTUVWf\n98765432}00t_n14rb_ym_d31rFGXl1ws_lr1ws4l}aEPONMLKJ{{w4nng_YDCBAzyxwvutsrIZaHqponmlkjihgfedcbabrolyabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ{_}123456789\nabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ{_}123456789\nabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ{_}123456789\nabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ{_}123456789\n'
</code></pre>
<p>We can see that there is another abroly in the output so now we need to consider what the program does. We know how to reverse a single swirl, but the program swirls every single directory starting from the farthest down. Encrypting the directory, moving it up one directory, encrypting again, until all of the subfolders have been encrypted into one single massive file. With the subfolders having been encrypted multiple times.</p>
<p>Lucily for us, the hacker wasn't very smart and added abroly to the end of each swirl so we basically have a partition that we can look up. So what we need to do it split on that partition and run the unswirl function yet again:</p>
<div class="lang-py editor-colors"># Imports
import numpy as np
import sys

# Factor the length as square-like as possible
# for maximum swirlage
def factosize(msg):
    ln = len(msg)
    # Start at the square
    start = int(np.sqrt(ln))
    # Keep checking
    for i in range((start+2)//1):
        x = start + i
        if ln % x == 0:
            return ln // x, x
    return "Not square enough! :C"

    
def unswirl(msg):
    bytmat = np.array(list(msg)).reshape(factosize(msg))
    
    # Some standard amount of swirl
    nperm = bytmat.size//5
    
    # Move dictionaries
    move_dic = {'N':(-1,0),'E':(0,1),'S':(1,0),'W':(0,-1)}
    turn_dic = {'N':'E','E':'S','S':'W','W':'N'}
    
    # SWIRL TIME 
    i_mat = np.arange(bytmat.size).reshape(bytmat.shape)
    # Get matrix shape
    h, w = bytmat.shape
    # Initial conditions
    y,x = 0,0    # start at 0,0
    movdir = 'E' # start going East
    vortex = [i_mat[y,x]]
    # Loop time
    i = 1
    while len(vortex) < i_mat.size:
        try:
            # Get new coords
            xnew = x + move_dic[movdir][1]
            ynew = y + move_dic[movdir][0]
            # Check if we hit an edge or a previous path
            if (movdir=='N') and (ynew < i//4): raise
            if (movdir=='E') and (xnew >= w-i//4): raise
            if (movdir=='S') and (ynew >= h-i//4): raise
            if (movdir=='W') and (xnew < i//4): raise
            # Append it to vortex list
            vortex.append(i_mat[ynew,xnew])
        except:
            # Turn clockwise
            movdir = turn_dic[movdir]
            i += 1
            continue
        # Set new coords
        x = xnew
        y = ynew
    # Permutate vortex
    if (nperm != 0) or (nperm != len(vortex)):
        perm = np.append(vortex[-nperm:], vortex[:-nperm])
    else:
        perm = vortex
    # Permutation dictionary
    perm_dic = { vortex[i] : int(perm[i]) for i in range(bytmat.size) }
    # Swirl the data
    swirled = np.zeros(bytmat.size, dtype=int)

    for i in range(bytmat.size):
        swirled[perm_dic[i]] = msg[i]

    return bytes(list(swirled))

enc = open(sys.argv[1], "rb").read().rstrip(b'abroly')

dec = unswirl(enc)

print(unswirl(dec.split(b'abroly')[0]))
</div>
<p>When run on the file the output is:</p>
<pre><code>b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ{_}123456789\nflag{w4nn4sw1rl_sw1rl3d_my_br41n_t00}'
</code></pre>

        </article>

        <footer class="footer text-left py-2 theme-bg-dark">

    <small class="copyright">&nbsp;Generated by <a href="https://github.com/Kasimir123/Blog-Generator" target="_blank">Blog Generator</a> from Kasimir123</small>

</footer>

    </div><!--//main-wrapper-->
    <!-- Javascript -->
    <script src="../../assets/js/popper.min.js"></script>
    <script src="../../assets/js/bootstrap.min.js"></script>
</body>
</html>